name: Release v4

on:
  push:
    branches:
      - v4
  workflow_dispatch:

concurrency:
  group: release-v4
  cancel-in-progress: false

jobs:
  release:
    if: ${{ github.event_name != 'push' || !contains(github.event.head_commit.message, '[skip release]') }}
    runs-on: blacksmith-4vcpu-windows-2025
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Validate required v4 files
        shell: pwsh
        run: |
          $required = @(
            "package.json",
            "src-tauri/tauri.conf.json",
            "src-tauri/Cargo.toml"
          )

          $missing = @()
          foreach ($path in $required) {
            if (-not (Test-Path $path)) {
              $missing += $path
            }
          }

          if ($missing.Count -gt 0) {
            throw "Missing required v4 files on this branch: $($missing -join ', '). Commit/push the v4 rewrite files first, then rerun Release v4."
          }

      - name: Resolve bump and channel
        id: controls
        uses: actions/github-script@v7
        with:
          script: |
            const message = (context.payload.head_commit?.message || "").toLowerCase();
            let bump = "patch";
            let channel = "beta";

            if (message.includes("[bump:minor]")) bump = "minor";
            if (message.includes("[bump:patch]")) bump = "patch";
            if (message.includes("[channel:stable]")) channel = "stable";
            if (message.includes("[channel:beta]")) channel = "beta";

            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });

            if (prs.data.length > 0) {
              const pr = prs.data.find((item) => item.base.ref === "v4") ?? prs.data[0];
              const labels = pr.labels.map((label) => String(label.name).toLowerCase());

              if (labels.includes("bump:minor")) bump = "minor";
              if (labels.includes("bump:patch")) bump = "patch";
              if (labels.includes("channel:stable")) channel = "stable";
              if (labels.includes("channel:beta")) channel = "beta";

              core.setOutput("pr_number", String(pr.number));
            }

            core.setOutput("bump", bump);
            core.setOutput("channel", channel);

      - name: Prepare version and release metadata
        id: meta
        run: bun .github/scripts/prepare-release.mjs
        env:
          RELEASE_BUMP: ${{ steps.controls.outputs.bump }}
          RELEASE_CHANNEL: ${{ steps.controls.outputs.channel }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Validate updater signing secrets
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY) {
            throw "Missing secret: TAURI_SIGNING_PRIVATE_KEY"
          }

          if (-not $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) {
            throw "Missing secret: TAURI_SIGNING_PRIVATE_KEY_PASSWORD"
          }

      - name: Build and publish release
        id: tauri_build
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          projectPath: "."
          tauriScript: "bun tauri"
          tagName: ${{ steps.meta.outputs.tag }}
          releaseName: ${{ steps.meta.outputs.release_title }}
          releaseBody: ${{ steps.meta.outputs.release_body }}
          prerelease: ${{ steps.controls.outputs.channel == 'beta' }}
          releaseDraft: false
          includeUpdaterJson: false

      - name: Upload portable EXE
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "${{ steps.meta.outputs.tag }}" "src-tauri/target/release/roblox-account-manager.exe" --clobber

      - name: Upload updater bundle
        id: updater_bundle
        continue-on-error: true
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          $tag = "${{ steps.meta.outputs.tag }}"
          New-Item -ItemType Directory -Path ".updater" -Force | Out-Null

          $updaterAsset = Get-ChildItem -Path "src-tauri\target\release\bundle" -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -match '\.nsis\.zip$|\.msi\.zip$|-setup\.exe$' } |
            Sort-Object -Property @{
              Expression = {
                if ($_.Name -match '\.nsis\.zip$') { 0 }
                elseif ($_.Name -match '-setup\.exe$') { 1 }
                else { 2 }
              }
            }, @{ Expression = { $_.LastWriteTimeUtc }; Descending = $true } |
            Select-Object -First 1

          if (-not $updaterAsset) {
            gh release download "$tag" --pattern "*-setup.exe" --dir ".updater" --clobber
            $updaterAsset = Get-ChildItem -Path ".updater" -File |
              Where-Object { $_.Name -match '-setup\.exe$' } |
              Select-Object -First 1
          }

          if (-not $updaterAsset) {
            throw "Could not resolve an updater asset (*.nsis.zip, *-setup.exe, or *.msi.zip) for release $tag"
          }

          $updaterPath = $updaterAsset.FullName
          $sigPath = "$updaterPath.sig"

          if (-not (Test-Path $sigPath)) {
            bunx tauri signer sign "$updaterPath"

            if (-not (Test-Path $sigPath) -and $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) {
              bunx tauri signer sign "$updaterPath" -p ""
            }
          }

          if (-not (Test-Path $sigPath)) {
            throw "Could not produce updater signature for $($updaterAsset.Name). Verify TAURI_SIGNING_PRIVATE_KEY and TAURI_SIGNING_PRIVATE_KEY_PASSWORD secrets."
          }

          gh release upload "$tag" "$updaterPath" "$sigPath" --clobber
          Set-Content -Path ".updater\updater-asset-name.txt" -Value $updaterAsset.Name -Encoding utf8

      - name: Build updater manifest
        if: ${{ steps.updater_bundle.outcome == 'success' }}
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          New-Item -ItemType Directory -Path ".updater" -Force | Out-Null

          $tag = "${{ steps.meta.outputs.tag }}"
          $repo = "${{ github.repository }}"
          $version = "${{ steps.meta.outputs.app_version }}"
          $preferredAssetName = $null
          if (Test-Path ".updater\updater-asset-name.txt") {
            $preferredAssetName = (Get-Content ".updater\updater-asset-name.txt" -Raw).Trim()
          }

          $release = gh release view "$tag" --repo "$repo" --json assets,publishedAt | ConvertFrom-Json
          $asset = $null

          if ($preferredAssetName) {
            $asset = $release.assets | Where-Object { $_.name -eq $preferredAssetName } | Select-Object -First 1
          }

          if (-not $asset) {
            $asset = $release.assets |
              Where-Object { $_.name -match '\.nsis\.zip$|-setup\.exe$|\.msi\.zip$' } |
              Sort-Object -Property @{
                Expression = {
                  if ($_.name -match '\.nsis\.zip$') { 0 }
                  elseif ($_.name -match '-setup\.exe$') { 1 }
                  else { 2 }
                }
              } |
              Select-Object -First 1
          }

          if (-not $asset) {
            throw "Updater asset was not found on release $tag"
          }

          $sigAssetName = "$($asset.name).sig"
          $sigPath = Join-Path ".updater" $sigAssetName
          if (-not (Test-Path $sigPath)) {
            gh release download "$tag" --repo "$repo" --pattern "$sigAssetName" --dir ".updater" --clobber
          }

          if (-not (Test-Path $sigPath)) {
            throw "Could not find updater signature asset on release: $sigAssetName"
          }

          $signature = (Get-Content -Path $sigPath -Raw).Trim()
          if (-not $signature) {
            throw "Updater signature file is empty: $sigPath"
          }

          $pubDate = $release.publishedAt
          if (-not $pubDate) {
            $pubDate = (Get-Date).ToUniversalTime().ToString("o")
          }

          $manifest = @{
            version = $version
            notes = "Roblox Account Manager $tag"
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                signature = $signature
                url = $asset.url
              }
            }
          } | ConvertTo-Json -Depth 8

          Set-Content -Path ".updater\latest.json" -Value $manifest -Encoding utf8

      - name: Publish channel manifest
        if: ${{ steps.updater_bundle.outcome == 'success' }}
        uses: actions/github-script@v7
        env:
          RELEASE_CHANNEL: ${{ steps.controls.outputs.channel }}
          RELEASE_TAG: ${{ steps.meta.outputs.tag }}
        with:
          script: |
            const fs = require("fs");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = "update-manifests";
            const channel = process.env.RELEASE_CHANNEL;
            const releaseTag = process.env.RELEASE_TAG;
            const filePath = `${channel}/latest.json`;
            const content = fs.readFileSync(".updater/latest.json", "utf8");

            try {
              await github.rest.repos.getBranch({ owner, repo, branch });
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }

              const repoInfo = await github.rest.repos.get({ owner, repo });
              const baseBranch = await github.rest.repos.getBranch({
                owner,
                repo,
                branch: repoInfo.data.default_branch
              });

              await github.rest.git.createRef({
                owner,
                repo,
                ref: `refs/heads/${branch}`,
                sha: baseBranch.data.commit.sha
              });
            }

            let sha;
            try {
              const existing = await github.rest.repos.getContent({
                owner,
                repo,
                path: filePath,
                ref: branch
              });
              sha = existing.data.sha;
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              branch,
              path: filePath,
              message: `chore(updater): update ${channel} manifest for ${releaseTag} [skip ci]`,
              content: Buffer.from(content, "utf8").toString("base64"),
              sha
            });

      - name: Updater signing warning
        if: ${{ steps.updater_bundle.outcome != 'success' }}
        shell: pwsh
        run: |
          Write-Warning "Updater bundle/signature upload was skipped because signing failed. Release binaries were still published."
          Write-Warning "Fix TAURI_SIGNING_PRIVATE_KEY and TAURI_SIGNING_PRIVATE_KEY_PASSWORD secrets to re-enable updater manifest publishing."
