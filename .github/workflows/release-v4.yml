name: Release v4

on:
  push:
    branches:
      - v4
    paths-ignore:
      - "**/*.md"
      - "**/*.MD"
  workflow_dispatch:

concurrency:
  group: release-v4
  cancel-in-progress: false

jobs:
  release:
    if: ${{ github.event_name != 'push' || !contains(github.event.head_commit.message, '[skip release]') }}
    runs-on: blacksmith-4vcpu-windows-2025
    permissions:
      contents: write
      pull-requests: read
    env:
      RELEASE_GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Validate required v4 files
        shell: pwsh
        run: |
          $required = @(
            "package.json",
            "src-tauri/tauri.conf.json",
            "src-tauri/Cargo.toml"
          )

          $missing = @()
          foreach ($path in $required) {
            if (-not (Test-Path $path)) {
              $missing += $path
            }
          }

          if ($missing.Count -gt 0) {
            throw "Missing required v4 files on this branch: $($missing -join ', '). Commit/push the v4 rewrite files first, then rerun Release v4."
          }

      - name: Resolve bump and channel
        id: controls
        uses: actions/github-script@v7
        with:
          script: |
            const message = (context.payload.head_commit?.message || "").toLowerCase();
            let bump = "patch";
            let channel = "beta";

            if (message.includes("[bump:minor]")) bump = "minor";
            if (message.includes("[bump:patch]")) bump = "patch";
            if (message.includes("[channel:stable]")) channel = "stable";
            if (message.includes("[channel:beta]")) channel = "beta";

            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });

            if (prs.data.length > 0) {
              const pr = prs.data.find((item) => item.base.ref === "v4") ?? prs.data[0];
              const labels = pr.labels.map((label) => String(label.name).toLowerCase());

              if (labels.includes("bump:minor")) bump = "minor";
              if (labels.includes("bump:patch")) bump = "patch";
              if (labels.includes("channel:stable")) channel = "stable";
              if (labels.includes("channel:beta")) channel = "beta";

              core.setOutput("pr_number", String(pr.number));
            }

            core.setOutput("bump", bump);
            core.setOutput("channel", channel);

      - name: Prepare version and release metadata
        id: meta
        run: bun .github/scripts/prepare-release.mjs
        env:
          RELEASE_BUMP: ${{ steps.controls.outputs.bump }}
          RELEASE_CHANNEL: ${{ steps.controls.outputs.channel }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}

      - name: Inject updater public key
        shell: pwsh
        run: |
          $config = Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json
          if (-not $config.plugins) { $config | Add-Member -Name "plugins" -Value ([PSCustomObject]@{}) -MemberType NoteProperty }
          if (-not $config.plugins.updater) { $config.plugins | Add-Member -Name "updater" -Value ([PSCustomObject]@{}) -MemberType NoteProperty }
          $config.plugins.updater | Add-Member -Name "pubkey" -Value "${{ secrets.TAURI_SIGNING_PUBLIC_KEY }}" -MemberType NoteProperty -Force
          $config | ConvertTo-Json -Depth 100 | Set-Content src-tauri/tauri.conf.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build and publish release
        id: tauri_build
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ env.RELEASE_GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          projectPath: "."
          tauriScript: "bun tauri"
          tagName: ${{ steps.meta.outputs.tag }}
          releaseName: ${{ steps.meta.outputs.release_title }}
          releaseBody: ${{ steps.meta.outputs.release_body }}
          generateReleaseNotes: true
          prerelease: ${{ steps.controls.outputs.channel == 'beta' }}
          releaseDraft: false

      - name: Upload portable EXE
        shell: pwsh
        env:
          GH_TOKEN: ${{ env.RELEASE_GITHUB_TOKEN }}
        run: |
          Copy-Item "src-tauri/target/release/roblox-account-manager.exe" "src-tauri/target/release/Roblox Account Manager_portable.exe"
          gh release upload "${{ steps.meta.outputs.tag }}" "src-tauri/target/release/Roblox Account Manager_portable.exe" --clobber

      - name: Generate and push update manifest
        shell: pwsh
        env:
          GH_TOKEN: ${{ env.RELEASE_GITHUB_TOKEN }}
          RELEASE_TAG: ${{ steps.meta.outputs.tag }}
          RELEASE_CHANNEL: ${{ steps.controls.outputs.channel }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          bun .github/scripts/generate-update-manifest.mjs

      - name: Clean up release assets
        shell: pwsh
        env:
          GH_TOKEN: ${{ env.RELEASE_GITHUB_TOKEN }}
        run: |
          gh release delete-asset "${{ steps.meta.outputs.tag }}" "latest.json" --yes
          gh release delete-asset "${{ steps.meta.outputs.tag }}" "roblox-account-manager.exe" --yes 2>$null

      - name: Finalize release notes
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RELEASE_GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = process.env.RELEASE_TAG;
            const channel = String(process.env.RELEASE_CHANNEL || "beta").toLowerCase();
            const appVersion = process.env.RELEASE_APP_VERSION;
            const previousTag = process.env.RELEASE_PREVIOUS_TAG;
            const releaseCommitSha = (context.payload.head_commit?.id || context.sha || "").slice(0, 7);

            let releaseCommitMessage = String(context.payload.head_commit?.message || "").trim();
            if (!releaseCommitMessage) {
              try {
                const commit = await github.rest.repos.getCommit({
                  owner,
                  repo,
                  ref: context.sha
                });
                releaseCommitMessage = String(commit.data.commit.message || "").trim();
              } catch (error) {
                core.warning(`Could not resolve release commit message from commit API: ${error.message}`);
              }
            }
            releaseCommitMessage = (releaseCommitMessage.split(/\r?\n/)[0] || "N/A").trim();

            const generatedNotes = await github.rest.repos.generateReleaseNotes({
              owner,
              repo,
              tag_name: tag,
              target_commitish: context.sha,
              ...(previousTag ? { previous_tag_name: previousTag } : {})
            });
            const generatedBody = String(generatedNotes.data.body || "").trim();

            const contributorSet = new Set();
            if (previousTag) {
              try {
                const compare = await github.rest.repos.compareCommitsWithBasehead({
                  owner,
                  repo,
                  basehead: `${previousTag}...${tag}`
                });
                for (const commit of compare.data.commits || []) {
                  const login = commit.author?.login;
                  if (login) {
                    contributorSet.add(login);
                  }
                }
              } catch (error) {
                core.warning(`Could not compute contributor range ${previousTag}...${tag}: ${error.message}`);
              }
            }

            const contributors = Array.from(contributorSet);
            let contributorsBlock = "## Contributors\n- No contributor metadata found for this release range.";
            if (contributors.length > 0) {
              const avatars = contributors
                .map((login) => `<a href=\"https://github.com/${login}\"><img src=\"https://github.com/${login}.png?size=64\" width=\"32\" height=\"32\" alt=\"@${login}\" /></a>`)
                .join(" ");
              const names = contributors
                .map((login) => `[@${login}](https://github.com/${login})`)
                .join(", ");
              contributorsBlock = `## Contributors\n${avatars}\n\n${names}`;
            }

            const channelLabel = channel === "beta" ? "Beta" : "Stable";
            const warningLine = channel === "beta"
              ? "This is a beta release. Missing features, bugs and crashes are possible. Run at your own risk."
              : "This is a stable release intended for general use.";
            const calloutType = channel === "beta" ? "WARNING" : "NOTE";

            const topNote = [
              `> [!${calloutType}]`,
              `> ${warningLine}`,
              "",
              `Channel: ${channelLabel}`,
              `Release commit: ${releaseCommitSha}`,
              `Release commit message: ${releaseCommitMessage}`,
              `App version: ${appVersion}`
            ].join("\n");

            const finalBody = [
              topNote,
              "",
              generatedBody || "## What's Changed\n- Release notes could not be generated.",
              "",
              contributorsBlock
            ].join("\n");

            const release = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag
            });

            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: release.data.id,
              body: finalBody
            });
        env:
          RELEASE_CHANNEL: ${{ steps.controls.outputs.channel }}
          RELEASE_TAG: ${{ steps.meta.outputs.tag }}
          RELEASE_APP_VERSION: ${{ steps.meta.outputs.app_version }}
          RELEASE_PREVIOUS_TAG: ${{ steps.meta.outputs.previous_tag }}
